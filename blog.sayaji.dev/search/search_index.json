{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blog Welcome to my technical blog. Here I share my journey with Cloud, DevOps, and Software Engineering. Latest Posts S3 Static Website Hosting a static website on AWS using CDK. Learn how to set up S3, CloudFront, and Route53 using Infrastructure as Code. Read More","title":"Blog"},{"location":"#blog","text":"Welcome to my technical blog. Here I share my journey with Cloud, DevOps, and Software Engineering.","title":"Blog"},{"location":"#latest-posts","text":"","title":"Latest Posts"},{"location":"posts/s3-static-website/","text":"From Manual AWS Setup to Infrastructure as Code: My CDK Journey Last week, I wanted to host a static website (like a blog or portfolio) on AWS. At first, I set up everything manually\u2014creating S3 buckets, CloudFront distributions, and Route53 DNS records through the AWS console. It worked, but I quickly ran into a problem: the process was tedious and not reproducible . For example, if I wanted to host blog.sayaji.dev , I would need to: Create an S3 bucket for storage Set up a CloudFront distribution for content delivery Configure DNS records in Route53 Repeat the same steps again for every new domain That's when I realized: This needs Infrastructure as Code (IaC) . I considered a few options: Terraform, Pulumi, or AWS CDK. I decided to go with AWS CDK , thinking it would be a great learning experience. What We're Building Here's the architecture we'll create with CDK: Our serverless infrastructure includes: Amazon S3 - Low-cost storage for static assets (HTML, CSS, JS, images) CloudFront - Global CDN for low-latency content delivery with SSL Route 53 - DNS management for custom domains API Gateway + Lambda - Dynamic features (visitor counter) DynamoDB - Data persistence Secrets Manager - Secure API authentication The Flow: 1. User visits resume.sayaji.dev 2. Route53 routes to CloudFront distribution 3. CloudFront serves static files from S3 4. JavaScript calls /count endpoint 5. CloudFront routes /count to API Gateway (with secret header) 6. API Gateway authorizer validates the secret 7. Counter Lambda updates DynamoDB and returns count 8. Frontend displays the visitor count Why AWS CDK? Before diving into code, let me explain why I chose CDK over other IaC tools. CDK uses three core concepts: Construct - A reusable building block (like a Lego brick) that creates AWS resources Stack - A logical deployment unit containing multiple constructs App - The root container for all your stacks I like to think of constructs as Lego bricks single, reusable pieces that create one or more AWS resources. For example: - s3.Bucket \u2192 creates an AWS S3 bucket - cloudfront.Distribution \u2192 creates a CloudFront distribution - route53.ARecord \u2192 creates a DNS record The beauty? You write TypeScript instead of YAML. Here's a simple example: new s3 . Bucket ( scope , 'WebsiteBucket' , { blockPublicAccess : s3.BlockPublicAccess.BLOCK_ALL , encryption : s3.BucketEncryption.S3_MANAGED , enforceSSL : true , }); The Pattern: Stack Composition Instead of one monolithic stack, I separated concerns into three stacks: const app = new cdk . App (); // 1. Base infrastructure (deploy once) const base = new BaseInfraStack ( app , \"BaseInfraStack\" , { env : { account : \"123456789\" , region : \"us-east-1\" }, }); // 2. Backend services (dynamic features) const backend = new BackendStack ( app , \"BackendStack\" , { env : { account : \"123456789\" , region : \"us-east-1\" }, }); // 3. Website stacks (reusable pattern) new ResumeStack ( app , \"ResumeStack\" , { hostedZoneId : base.hostedZone.hostedZoneId , certificateArn : base.certificate.certificateArn , apiUrl : backend.apiUrl , cfSecret : backend.cfSecret , }); app . synth (); Why this pattern? 1. Deploy shared resources once (Route53, ACM Certificate) 2. Pass outputs between stacks using cross-stack references 3. Reuse patterns across multiple websites Key Constructs Let me show you the most important constructs I built. 1. S3 Bucket (Secure by Default) export class WebsiteBucket extends Construct { public readonly bucket : s3.Bucket ; constructor ( scope : Construct , id : string , props : MyBucketProps ) { super ( scope , id ); this . bucket = new s3 . Bucket ( this , \"Bucket\" , { bucketName : props.bucketName , websiteIndexDocument : \"index.html\" , blockPublicAccess : s3.BlockPublicAccess.BLOCK_ALL , // Security first! removalPolicy : RemovalPolicy.DESTROY , }); } } Key decision: Block all public access. CloudFront accesses S3 using Origin Access Control (OAC), not public URLs. 2. CloudFront Distribution (Multi-Origin) This was the trickiest part. I needed CloudFront to serve: - Static content from S3 (default behavior) - API requests to API Gateway (path /count ) export class WebsiteDistribution extends Construct { constructor ( scope : Construct , id : string , props : CloudFrontProps ) { super ( scope , id ); // Optional API origin for dynamic features const apiOrigin = props . apiUrl ? new origins . HttpOrigin ( extractDomain ( props . apiUrl ), { protocolPolicy : cloudfront.OriginProtocolPolicy.HTTPS_ONLY , customHeaders : { \"x-cf-secret\" : props . cfSecret . secretValueFromJson ( 'x-cf-secret' ). unsafeUnwrap () }, }) : undefined ; this . distribution = new cloudfront . Distribution ( this , \"Distribution\" , { defaultBehavior : { origin : props.s3Origin , viewerProtocolPolicy : cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS , }, // Route /count to API Gateway additionalBehaviors : apiOrigin ? { [ props . apiPath ] : { origin : apiOrigin , cachePolicy : cloudfront.CachePolicy.CACHING_DISABLED , }, } : undefined , domainNames : [ props . siteDomain ], certificate : props.certificate , }); } } The magic: CloudFront automatically adds the x-cf-secret header to API requests, which the Lambda authorizer validates. This prevents direct API access! 3. Lambda + DynamoDB (Visitor Counter) The counter Lambda tracks unique visitors by IP: def handler ( event , context ): src_ip = event . get ( \"headers\" , {}) . get ( \"x-forwarded-for\" , \"\" ) . split ( \",\" )[ 0 ] . strip () if not src_ip : return { \"statusCode\" : 400 , \"body\" : json . dumps ({ \"message\" : \"No IP found\" })} # Try to insert IP, fail silently if it exists try : table . put_item ( Item = { \"id\" : src_ip }, ConditionExpression = \"attribute_not_exists(id)\" # Only insert if new ) except ClientError as e : if e . response [ \"Error\" ][ \"Code\" ] != \"ConditionalCheckFailedException\" : raise # Count all unique IPs total = table . scan ( Select = \"COUNT\" )[ \"Count\" ] return { \"statusCode\" : 200 , \"body\" : json . dumps ({ \"ip\" : src_ip , \"unique_visitors\" : total }) } DynamoDB table: new dynamodb . Table ( this , \"CounterTable\" , { partitionKey : { name : \"id\" , type : dynamodb . AttributeType . STRING }, billingMode : dynamodb.BillingMode.PAY_PER_REQUEST , // Serverless pricing! }); Challenges I Faced 1. CloudFront Origin Access Control (OAC) Initially, I used the deprecated Origin Access Identity (OAI). Switching to OAC took some trial and error: // \u274c Old way (deprecated) origins . S3Origin . withOriginAccessIdentity ( bucket ) // \u2705 New way origins . S3BucketOrigin . withOriginAccessControl ( bucket ) 2. Cross-Stack References Passing values between stacks required enabling crossRegionReferences : new BaseInfraStack ( app , \"BaseInfraStack\" , { crossRegionReferences : true , // Required! }); 3. API Gateway Authorizer Setting up the Lambda authorizer was tricky. The authorizer must return an IAM policy: def generate_policy ( principal_id , effect , resource ): return { \"principalId\" : principal_id , \"policyDocument\" : { \"Version\" : \"2012-10-17\" , \"Statement\" : [{ \"Action\" : \"execute-api:Invoke\" , \"Effect\" : effect , # \"Allow\" or \"Deny\" \"Resource\" : resource }] }, } Testing Strategy I use two types of tests : 1. Python Unit Tests (Lambda Functions) class CounterLambdaTest ( unittest . TestCase ): @mock . patch ( \"lambda_functions.counter.index.table\" ) def test_lambda_success ( self , mock_table ): mock_table . put_item . return_value = {} mock_table . scan . return_value = { \"Count\" : 123 } event = { \"headers\" : { \"x-forwarded-for\" : \"1.2.3.4\" }} response = handler ( event , None ) self . assertEqual ( response [ \"statusCode\" ], 200 ) self . assertIn ( \"unique_visitors\" , json . loads ( response [ \"body\" ])) 2. CDK Snapshot Tests (Infrastructure) test ( 'Base Infrastructure creates Route53 and ACM' , () => { const app = new cdk . App (); const stack = new BaseInfraStack ( app , 'TestStack' ); const template = Template . fromStack ( stack ); template . hasResourceProperties ( 'AWS::Route53::HostedZone' , { Name : 'sayaji.dev.' , }); }); Run tests: # Python tests python -m unittest discover -s ./test -p \"test_*.py\" -v # CDK tests npm test CI/CD Pipeline I use GitHub Actions with a 6-stage pipeline: 1. Setup \u2192 Install dependencies (cached) 2. Tests \u2192 Run Python + CDK tests 3. Plan \u2192 CDK diff (show changes) 4. Approval \u2192 Manual approval for production 5. Deploy \u2192 Deploy to AWS 6. Notify \u2192 Send notifications Key features: - OIDC Authentication - No AWS credentials stored in GitHub! - PR Comments - Automatically comments CDK diff on pull requests - Manual Approval - Production deployments require approval plan : steps : - name : Configure AWS (OIDC) uses : aws-actions/configure-aws-credentials@v4 with : role-to-assume : arn:aws:iam::123456789:role/Github_Actions_Role aws-region : us-east-1 - name : CDK Diff run : cdk diff --all See the full CI/CD workflow on GitHub Lessons Learned After building this infrastructure, here are my key takeaways: Start Simple - I began with just S3 + CloudFront, then added features incrementally Constructs are Powerful - Reusable constructs saved me hours of repetitive code Test Early - Writing tests alongside infrastructure caught bugs before deployment Security First - Block public S3 access, use OIDC, implement authorizers Stack Composition - Separating base/backend/website stacks makes updates safer Documentation Matters - AWS CDK docs are good, but real examples are better What's Next? Now that the foundation is solid, here are some ideas I'm exploring: 1. Add More Websites The beauty of this pattern is reusability: new PortfolioStack ( app , \"PortfolioStack\" , { ... baseProps , siteDomain : \"portfolio.sayaji.dev\" , }); 2. Monitoring & Alerts Add CloudWatch alarms for errors: const errorAlarm = new cloudwatch . Alarm ( this , 'LambdaErrors' , { metric : counterLambda.function.metricErrors (), threshold : 5 , evaluationPeriods : 1 , }); 3. Cost Optimization Enable CloudFront caching with longer TTLs Use S3 Intelligent-Tiering Set DynamoDB to on-demand billing 4. WAF for Security Protect against DDoS and common attacks with AWS WAF rate limiting. Conclusion Building this infrastructure taught me that Infrastructure as Code isn't just about automation\u2014it's about reproducibility, testability, and maintainability . What started as a manual, error-prone process is now: \u2705 Reproducible - Deploy to any AWS account with cdk deploy \u2705 Scalable - Serverless architecture handles traffic spikes \u2705 Secure - No public S3 access, API authentication, HTTPS everywhere \u2705 Cost-effective - Pay only for what you use \u2705 Testable - Comprehensive tests catch bugs before deployment \u2705 Automated - CI/CD pipeline handles everything The complete code is available on GitHub . If you're considering AWS CDK for your next project, I highly recommend it. The learning curve is worth it! Have questions or suggestions? Feel free to reach out or open an issue on GitHub!","title":"S3 Static Website"},{"location":"posts/s3-static-website/#from-manual-aws-setup-to-infrastructure-as-code-my-cdk-journey","text":"Last week, I wanted to host a static website (like a blog or portfolio) on AWS. At first, I set up everything manually\u2014creating S3 buckets, CloudFront distributions, and Route53 DNS records through the AWS console. It worked, but I quickly ran into a problem: the process was tedious and not reproducible . For example, if I wanted to host blog.sayaji.dev , I would need to: Create an S3 bucket for storage Set up a CloudFront distribution for content delivery Configure DNS records in Route53 Repeat the same steps again for every new domain That's when I realized: This needs Infrastructure as Code (IaC) . I considered a few options: Terraform, Pulumi, or AWS CDK. I decided to go with AWS CDK , thinking it would be a great learning experience.","title":"From Manual AWS Setup to Infrastructure as Code: My CDK Journey"},{"location":"posts/s3-static-website/#what-were-building","text":"Here's the architecture we'll create with CDK: Our serverless infrastructure includes: Amazon S3 - Low-cost storage for static assets (HTML, CSS, JS, images) CloudFront - Global CDN for low-latency content delivery with SSL Route 53 - DNS management for custom domains API Gateway + Lambda - Dynamic features (visitor counter) DynamoDB - Data persistence Secrets Manager - Secure API authentication The Flow: 1. User visits resume.sayaji.dev 2. Route53 routes to CloudFront distribution 3. CloudFront serves static files from S3 4. JavaScript calls /count endpoint 5. CloudFront routes /count to API Gateway (with secret header) 6. API Gateway authorizer validates the secret 7. Counter Lambda updates DynamoDB and returns count 8. Frontend displays the visitor count","title":"What We're Building"},{"location":"posts/s3-static-website/#why-aws-cdk","text":"Before diving into code, let me explain why I chose CDK over other IaC tools. CDK uses three core concepts: Construct - A reusable building block (like a Lego brick) that creates AWS resources Stack - A logical deployment unit containing multiple constructs App - The root container for all your stacks I like to think of constructs as Lego bricks single, reusable pieces that create one or more AWS resources. For example: - s3.Bucket \u2192 creates an AWS S3 bucket - cloudfront.Distribution \u2192 creates a CloudFront distribution - route53.ARecord \u2192 creates a DNS record The beauty? You write TypeScript instead of YAML. Here's a simple example: new s3 . Bucket ( scope , 'WebsiteBucket' , { blockPublicAccess : s3.BlockPublicAccess.BLOCK_ALL , encryption : s3.BucketEncryption.S3_MANAGED , enforceSSL : true , });","title":"Why AWS CDK?"},{"location":"posts/s3-static-website/#the-pattern-stack-composition","text":"Instead of one monolithic stack, I separated concerns into three stacks: const app = new cdk . App (); // 1. Base infrastructure (deploy once) const base = new BaseInfraStack ( app , \"BaseInfraStack\" , { env : { account : \"123456789\" , region : \"us-east-1\" }, }); // 2. Backend services (dynamic features) const backend = new BackendStack ( app , \"BackendStack\" , { env : { account : \"123456789\" , region : \"us-east-1\" }, }); // 3. Website stacks (reusable pattern) new ResumeStack ( app , \"ResumeStack\" , { hostedZoneId : base.hostedZone.hostedZoneId , certificateArn : base.certificate.certificateArn , apiUrl : backend.apiUrl , cfSecret : backend.cfSecret , }); app . synth (); Why this pattern? 1. Deploy shared resources once (Route53, ACM Certificate) 2. Pass outputs between stacks using cross-stack references 3. Reuse patterns across multiple websites","title":"The Pattern: Stack Composition"},{"location":"posts/s3-static-website/#key-constructs","text":"Let me show you the most important constructs I built.","title":"Key Constructs"},{"location":"posts/s3-static-website/#1-s3-bucket-secure-by-default","text":"export class WebsiteBucket extends Construct { public readonly bucket : s3.Bucket ; constructor ( scope : Construct , id : string , props : MyBucketProps ) { super ( scope , id ); this . bucket = new s3 . Bucket ( this , \"Bucket\" , { bucketName : props.bucketName , websiteIndexDocument : \"index.html\" , blockPublicAccess : s3.BlockPublicAccess.BLOCK_ALL , // Security first! removalPolicy : RemovalPolicy.DESTROY , }); } } Key decision: Block all public access. CloudFront accesses S3 using Origin Access Control (OAC), not public URLs.","title":"1. S3 Bucket (Secure by Default)"},{"location":"posts/s3-static-website/#2-cloudfront-distribution-multi-origin","text":"This was the trickiest part. I needed CloudFront to serve: - Static content from S3 (default behavior) - API requests to API Gateway (path /count ) export class WebsiteDistribution extends Construct { constructor ( scope : Construct , id : string , props : CloudFrontProps ) { super ( scope , id ); // Optional API origin for dynamic features const apiOrigin = props . apiUrl ? new origins . HttpOrigin ( extractDomain ( props . apiUrl ), { protocolPolicy : cloudfront.OriginProtocolPolicy.HTTPS_ONLY , customHeaders : { \"x-cf-secret\" : props . cfSecret . secretValueFromJson ( 'x-cf-secret' ). unsafeUnwrap () }, }) : undefined ; this . distribution = new cloudfront . Distribution ( this , \"Distribution\" , { defaultBehavior : { origin : props.s3Origin , viewerProtocolPolicy : cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS , }, // Route /count to API Gateway additionalBehaviors : apiOrigin ? { [ props . apiPath ] : { origin : apiOrigin , cachePolicy : cloudfront.CachePolicy.CACHING_DISABLED , }, } : undefined , domainNames : [ props . siteDomain ], certificate : props.certificate , }); } } The magic: CloudFront automatically adds the x-cf-secret header to API requests, which the Lambda authorizer validates. This prevents direct API access!","title":"2. CloudFront Distribution (Multi-Origin)"},{"location":"posts/s3-static-website/#3-lambda-dynamodb-visitor-counter","text":"The counter Lambda tracks unique visitors by IP: def handler ( event , context ): src_ip = event . get ( \"headers\" , {}) . get ( \"x-forwarded-for\" , \"\" ) . split ( \",\" )[ 0 ] . strip () if not src_ip : return { \"statusCode\" : 400 , \"body\" : json . dumps ({ \"message\" : \"No IP found\" })} # Try to insert IP, fail silently if it exists try : table . put_item ( Item = { \"id\" : src_ip }, ConditionExpression = \"attribute_not_exists(id)\" # Only insert if new ) except ClientError as e : if e . response [ \"Error\" ][ \"Code\" ] != \"ConditionalCheckFailedException\" : raise # Count all unique IPs total = table . scan ( Select = \"COUNT\" )[ \"Count\" ] return { \"statusCode\" : 200 , \"body\" : json . dumps ({ \"ip\" : src_ip , \"unique_visitors\" : total }) } DynamoDB table: new dynamodb . Table ( this , \"CounterTable\" , { partitionKey : { name : \"id\" , type : dynamodb . AttributeType . STRING }, billingMode : dynamodb.BillingMode.PAY_PER_REQUEST , // Serverless pricing! });","title":"3. Lambda + DynamoDB (Visitor Counter)"},{"location":"posts/s3-static-website/#challenges-i-faced","text":"","title":"Challenges I Faced"},{"location":"posts/s3-static-website/#1-cloudfront-origin-access-control-oac","text":"Initially, I used the deprecated Origin Access Identity (OAI). Switching to OAC took some trial and error: // \u274c Old way (deprecated) origins . S3Origin . withOriginAccessIdentity ( bucket ) // \u2705 New way origins . S3BucketOrigin . withOriginAccessControl ( bucket )","title":"1. CloudFront Origin Access Control (OAC)"},{"location":"posts/s3-static-website/#2-cross-stack-references","text":"Passing values between stacks required enabling crossRegionReferences : new BaseInfraStack ( app , \"BaseInfraStack\" , { crossRegionReferences : true , // Required! });","title":"2. Cross-Stack References"},{"location":"posts/s3-static-website/#3-api-gateway-authorizer","text":"Setting up the Lambda authorizer was tricky. The authorizer must return an IAM policy: def generate_policy ( principal_id , effect , resource ): return { \"principalId\" : principal_id , \"policyDocument\" : { \"Version\" : \"2012-10-17\" , \"Statement\" : [{ \"Action\" : \"execute-api:Invoke\" , \"Effect\" : effect , # \"Allow\" or \"Deny\" \"Resource\" : resource }] }, }","title":"3. API Gateway Authorizer"},{"location":"posts/s3-static-website/#testing-strategy","text":"I use two types of tests :","title":"Testing Strategy"},{"location":"posts/s3-static-website/#1-python-unit-tests-lambda-functions","text":"class CounterLambdaTest ( unittest . TestCase ): @mock . patch ( \"lambda_functions.counter.index.table\" ) def test_lambda_success ( self , mock_table ): mock_table . put_item . return_value = {} mock_table . scan . return_value = { \"Count\" : 123 } event = { \"headers\" : { \"x-forwarded-for\" : \"1.2.3.4\" }} response = handler ( event , None ) self . assertEqual ( response [ \"statusCode\" ], 200 ) self . assertIn ( \"unique_visitors\" , json . loads ( response [ \"body\" ]))","title":"1. Python Unit Tests (Lambda Functions)"},{"location":"posts/s3-static-website/#2-cdk-snapshot-tests-infrastructure","text":"test ( 'Base Infrastructure creates Route53 and ACM' , () => { const app = new cdk . App (); const stack = new BaseInfraStack ( app , 'TestStack' ); const template = Template . fromStack ( stack ); template . hasResourceProperties ( 'AWS::Route53::HostedZone' , { Name : 'sayaji.dev.' , }); }); Run tests: # Python tests python -m unittest discover -s ./test -p \"test_*.py\" -v # CDK tests npm test","title":"2. CDK Snapshot Tests (Infrastructure)"},{"location":"posts/s3-static-website/#cicd-pipeline","text":"I use GitHub Actions with a 6-stage pipeline: 1. Setup \u2192 Install dependencies (cached) 2. Tests \u2192 Run Python + CDK tests 3. Plan \u2192 CDK diff (show changes) 4. Approval \u2192 Manual approval for production 5. Deploy \u2192 Deploy to AWS 6. Notify \u2192 Send notifications Key features: - OIDC Authentication - No AWS credentials stored in GitHub! - PR Comments - Automatically comments CDK diff on pull requests - Manual Approval - Production deployments require approval plan : steps : - name : Configure AWS (OIDC) uses : aws-actions/configure-aws-credentials@v4 with : role-to-assume : arn:aws:iam::123456789:role/Github_Actions_Role aws-region : us-east-1 - name : CDK Diff run : cdk diff --all See the full CI/CD workflow on GitHub","title":"CI/CD Pipeline"},{"location":"posts/s3-static-website/#lessons-learned","text":"After building this infrastructure, here are my key takeaways: Start Simple - I began with just S3 + CloudFront, then added features incrementally Constructs are Powerful - Reusable constructs saved me hours of repetitive code Test Early - Writing tests alongside infrastructure caught bugs before deployment Security First - Block public S3 access, use OIDC, implement authorizers Stack Composition - Separating base/backend/website stacks makes updates safer Documentation Matters - AWS CDK docs are good, but real examples are better","title":"Lessons Learned"},{"location":"posts/s3-static-website/#whats-next","text":"Now that the foundation is solid, here are some ideas I'm exploring:","title":"What's Next?"},{"location":"posts/s3-static-website/#1-add-more-websites","text":"The beauty of this pattern is reusability: new PortfolioStack ( app , \"PortfolioStack\" , { ... baseProps , siteDomain : \"portfolio.sayaji.dev\" , });","title":"1. Add More Websites"},{"location":"posts/s3-static-website/#2-monitoring-alerts","text":"Add CloudWatch alarms for errors: const errorAlarm = new cloudwatch . Alarm ( this , 'LambdaErrors' , { metric : counterLambda.function.metricErrors (), threshold : 5 , evaluationPeriods : 1 , });","title":"2. Monitoring &amp; Alerts"},{"location":"posts/s3-static-website/#3-cost-optimization","text":"Enable CloudFront caching with longer TTLs Use S3 Intelligent-Tiering Set DynamoDB to on-demand billing","title":"3. Cost Optimization"},{"location":"posts/s3-static-website/#4-waf-for-security","text":"Protect against DDoS and common attacks with AWS WAF rate limiting.","title":"4. WAF for Security"},{"location":"posts/s3-static-website/#conclusion","text":"Building this infrastructure taught me that Infrastructure as Code isn't just about automation\u2014it's about reproducibility, testability, and maintainability . What started as a manual, error-prone process is now: \u2705 Reproducible - Deploy to any AWS account with cdk deploy \u2705 Scalable - Serverless architecture handles traffic spikes \u2705 Secure - No public S3 access, API authentication, HTTPS everywhere \u2705 Cost-effective - Pay only for what you use \u2705 Testable - Comprehensive tests catch bugs before deployment \u2705 Automated - CI/CD pipeline handles everything The complete code is available on GitHub . If you're considering AWS CDK for your next project, I highly recommend it. The learning curve is worth it! Have questions or suggestions? Feel free to reach out or open an issue on GitHub!","title":"Conclusion"}]}