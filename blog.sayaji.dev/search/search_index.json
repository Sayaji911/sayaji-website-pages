{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"posts/s3-static-website/","text":"From Manual AWS Setup to Infrastructure as Code: My CDK Journey Last week, I wanted to host a static website on AWS. I started with creating S3 buckets, CloudFront distributions, and Route53 manually. It worked, but it soon began to feel tedious and not reproducible. For every new domain I needed to host, I would need to: Create an S3 bucket. Set up a CloudFront distribution. Configure DNS records in Route53 But this reproducibility problem can be solved with IaC. I considered a few options: Terraform, Pulumi, or AWS CDK. I decided to go with AWS CDK . I thought it would be a great learning experience. What We're Building Here's the architecture we'll create with CDK: Our serverless infrastructure includes: Amazon S3 - Low-cost storage for static assets (HTML, CSS, JS, images) CloudFront - Global CDN for low-latency content delivery with SSL Route 53 - DNS management for custom domains API Gateway + Lambda - Dynamic features (visitor counter) DynamoDB - Store the visitor count Secrets Manager - Store the API secret The Flow: 1. User visits resume.sayaji.dev 2. Route53 routes to CloudFront distribution 3. CloudFront serves static files from S3 4. JavaScript calls /count endpoint 5. CloudFront routes /count to API Gateway (with secret header) 6. API Gateway authorizer validates the secret 7. Counter Lambda updates DynamoDB and returns count 8. Frontend displays the visitor count Why AWS CDK? I think CDK is new territory for me. I have used other IaC tools like Terraform and I liked them. But I wanted to try something new. CDK uses three core concepts: Construct - A reusable building block (like a Lego brick) that creates AWS resources Stack - A logical deployment unit containing multiple constructs App - The root container for all your stacks I like to think of constructs as Lego bricks single, reusable pieces that create one or more AWS resources. For example: - s3.Bucket \u2192 creates an AWS S3 bucket - cloudfront.Distribution \u2192 creates a CloudFront distribution - route53.ARecord \u2192 creates a DNS record As a developer turned DevOps engineer, I find it easier to write code than YAML. Below is a small example of creating an S3 bucket using CDK. new s3 . Bucket ( scope , 'WebsiteBucket' , { blockPublicAccess : s3.BlockPublicAccess.BLOCK_ALL , encryption : s3.BucketEncryption.S3_MANAGED , enforceSSL : true , }); The Pattern: Stack Composition Instead of creating one giant stack, I split the stack into multiple logical stacks. const app = new cdk . App (); // 1. Base infrastructure (deploy once) const base = new BaseInfraStack ( app , \"BaseInfraStack\" , { env : { account : \"123456789\" , region : \"us-east-1\" }, }); // 2. Backend services (dynamic features) const backend = new BackendStack ( app , \"BackendStack\" , { env : { account : \"123456789\" , region : \"us-east-1\" }, }); // 3. Website stacks (reusable pattern) new ResumeStack ( app , \"ResumeStack\" , { hostedZoneId : base.hostedZone.hostedZoneId , certificateArn : base.certificate.certificateArn , apiUrl : backend.apiUrl , cfSecret : backend.cfSecret , }); app . synth (); Why this pattern? Deploy common resources once : Route53 and ACM Certificates will be the same for subdomains, so it best fits for BaseInfraStack, whereas BackendStack will have API Gateway and Lambda functions and WebsiteStack will have S3 bucket and CloudFront distribution. Pass outputs between stacks : We can pass outputs of one stack to another stack. For example, we require the API GW url and secret from BackendStack to WebsiteStack. Reuse patterns : Now this pattern can be reused for any subdomain I will create. Key Constructs Let me show you the most important constructs I built. 1. S3 Bucket (Secure by Default) export class WebsiteBucket extends Construct { public readonly bucket : s3.Bucket ; constructor ( scope : Construct , id : string , props : MyBucketProps ) { super ( scope , id ); this . bucket = new s3 . Bucket ( this , \"Bucket\" , { bucketName : props.bucketName , websiteIndexDocument : \"index.html\" , blockPublicAccess : s3.BlockPublicAccess.BLOCK_ALL , // Security first! removalPolicy : RemovalPolicy.DESTROY , }); } } 2. CloudFront Distribution (Multi-Origin) This was the challenging part - Static content from S3 (default behavior) - API requests to API Gateway (path /count ) export class WebsiteDistribution extends Construct { constructor ( scope : Construct , id : string , props : CloudFrontProps ) { super ( scope , id ); // Optional API origin for dynamic features const apiOrigin = props . apiUrl ? new origins . HttpOrigin ( extractDomain ( props . apiUrl ), { protocolPolicy : cloudfront.OriginProtocolPolicy.HTTPS_ONLY , customHeaders : { \"x-cf-secret\" : props . cfSecret . secretValueFromJson ( 'x-cf-secret' ). unsafeUnwrap () }, }) : undefined ; this . distribution = new cloudfront . Distribution ( this , \"Distribution\" , { defaultBehavior : { origin : props.s3Origin , viewerProtocolPolicy : cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS , }, // Route /count to API Gateway additionalBehaviors : apiOrigin ? { [ props . apiPath ] : { origin : apiOrigin , cachePolicy : cloudfront.CachePolicy.CACHING_DISABLED , }, } : undefined , domainNames : [ props . siteDomain ], certificate : props.certificate , }); } } How do I stop direct API access? I added x-cf-secret header to API requests injected by CloudFront, which the Lambda authorizer validates. This prevents direct API access! 3. Lambda + DynamoDB (Visitor Counter) The counter Lambda tracks unique visitors by IP: def handler ( event , context ): src_ip = event . get ( \"headers\" , {}) . get ( \"x-forwarded-for\" , \"\" ) . split ( \",\" )[ 0 ] . strip () if not src_ip : return { \"statusCode\" : 400 , \"body\" : json . dumps ({ \"message\" : \"No IP found\" })} # Try to insert IP, fail silently if it exists try : table . put_item ( Item = { \"id\" : src_ip }, ConditionExpression = \"attribute_not_exists(id)\" # Only insert if new ) except ClientError as e : if e . response [ \"Error\" ][ \"Code\" ] != \"ConditionalCheckFailedException\" : raise # Count all unique IPs total = table . scan ( Select = \"COUNT\" )[ \"Count\" ] return { \"statusCode\" : 200 , \"body\" : json . dumps ({ \"ip\" : src_ip , \"unique_visitors\" : total }) } I know, I know, storing IP addresses is not the best way to do it, but it works for now (maybe Flask + SQLite in WAL mode. In-memory IP address rate limiting), but this is for the future. DynamoDB table: new dynamodb . Table ( this , \"CounterTable\" , { partitionKey : { name : \"id\" , type : dynamodb . AttributeType . STRING }, billingMode : dynamodb.BillingMode.PAY_PER_REQUEST , // Serverless pricing! }); Challenges I Faced 1. Cross-Stack References Passing values between stacks required enabling crossRegionReferences : new BaseInfraStack ( app , \"BaseInfraStack\" , { crossRegionReferences : true , // Required! }); 2. API Gateway Authorizer Setting up the Lambda authorizer was tricky. The authorizer must return an IAM policy: def generate_policy ( principal_id , effect , resource ): return { \"principalId\" : principal_id , \"policyDocument\" : { \"Version\" : \"2012-10-17\" , \"Statement\" : [{ \"Action\" : \"execute-api:Invoke\" , \"Effect\" : effect , # \"Allow\" or \"Deny\" \"Resource\" : resource }] }, } 3. GitHub OIDC Setting up GitHub OIDC was a bit tricky. I had to enable the oidc provider in the github-actions.yml file: permissions : id-token : write contents : read Testing Strategy Python Unit Tests (Lambda Functions) class CounterLambdaTest ( unittest . TestCase ): @mock . patch ( \"lambda_functions.counter.index.table\" ) def test_lambda_success ( self , mock_table ): mock_table . put_item . return_value = {} mock_table . scan . return_value = { \"Count\" : 123 } event = { \"headers\" : { \"x-forwarded-for\" : \"1.2.3.4\" }} response = handler ( event , None ) self . assertEqual ( response [ \"statusCode\" ], 200 ) self . assertIn ( \"unique_visitors\" , json . loads ( response [ \"body\" ])) Run tests: # Python tests python -m unittest discover -s ./test -p \"test_*.py\" -v CI/CD Pipeline I use GitHub Actions with a six-stage pipeline: Setup \u2192 Install dependencies (cached) Tests \u2192 Run Python + CDK tests Plan \u2192 CDK diff (show changes) Approval \u2192 Manual approval for production Deploy \u2192 Deploy to AWS Notify \u2192 Send notifications Key features: - OIDC Authentication - No AWS credentials stored in GitHub! - PR Comments - Automatically comments CDK diff on pull requests - Manual Approval - Production deployments require approval Lessons Learned After building this infrastructure, here are my key takeaways: Start Simple - Just start and start small and fast. Don't overcomplicate things. Use Constructs where possible - Reusable constructs have saved me hours from writing the same code again and again. Security Shift Left - I blocked public access to S3, used OIDC and implemented authorizers Stack Composition - Separating stacks makes it easier to maintain and also it is safer to update one stack without breaking the other. What's Next? Now that we have the foundation solid, here are some ideas I will be exploring: 1. Monitoring & Alerts We can use New Relic or Data Dog to monitor our simple infrastructure. 2. Optimizing Costs It costs me less than $5 per month to run this infrastructure. 3. WAF for Security Protect against DDoS and common attacks with AWS WAF rate limiting. (but this is expensive!) Conclusion It was fun doing this, and I learned a lot about CDK and AWS. As a developer, I find CDK fluid and feels like I am slipping into a familiar pair of shoes. We get to use constructs, functions, loops and variables and suddenly infrastructure stops feeling like configuration files and starts feeling like code.","title":"S3 Static Website"},{"location":"posts/s3-static-website/#from-manual-aws-setup-to-infrastructure-as-code-my-cdk-journey","text":"Last week, I wanted to host a static website on AWS. I started with creating S3 buckets, CloudFront distributions, and Route53 manually. It worked, but it soon began to feel tedious and not reproducible. For every new domain I needed to host, I would need to: Create an S3 bucket. Set up a CloudFront distribution. Configure DNS records in Route53 But this reproducibility problem can be solved with IaC. I considered a few options: Terraform, Pulumi, or AWS CDK. I decided to go with AWS CDK . I thought it would be a great learning experience.","title":"From Manual AWS Setup to Infrastructure as Code: My CDK Journey"},{"location":"posts/s3-static-website/#what-were-building","text":"Here's the architecture we'll create with CDK: Our serverless infrastructure includes: Amazon S3 - Low-cost storage for static assets (HTML, CSS, JS, images) CloudFront - Global CDN for low-latency content delivery with SSL Route 53 - DNS management for custom domains API Gateway + Lambda - Dynamic features (visitor counter) DynamoDB - Store the visitor count Secrets Manager - Store the API secret The Flow: 1. User visits resume.sayaji.dev 2. Route53 routes to CloudFront distribution 3. CloudFront serves static files from S3 4. JavaScript calls /count endpoint 5. CloudFront routes /count to API Gateway (with secret header) 6. API Gateway authorizer validates the secret 7. Counter Lambda updates DynamoDB and returns count 8. Frontend displays the visitor count","title":"What We're Building"},{"location":"posts/s3-static-website/#why-aws-cdk","text":"I think CDK is new territory for me. I have used other IaC tools like Terraform and I liked them. But I wanted to try something new. CDK uses three core concepts: Construct - A reusable building block (like a Lego brick) that creates AWS resources Stack - A logical deployment unit containing multiple constructs App - The root container for all your stacks I like to think of constructs as Lego bricks single, reusable pieces that create one or more AWS resources. For example: - s3.Bucket \u2192 creates an AWS S3 bucket - cloudfront.Distribution \u2192 creates a CloudFront distribution - route53.ARecord \u2192 creates a DNS record As a developer turned DevOps engineer, I find it easier to write code than YAML. Below is a small example of creating an S3 bucket using CDK. new s3 . Bucket ( scope , 'WebsiteBucket' , { blockPublicAccess : s3.BlockPublicAccess.BLOCK_ALL , encryption : s3.BucketEncryption.S3_MANAGED , enforceSSL : true , });","title":"Why AWS CDK?"},{"location":"posts/s3-static-website/#the-pattern-stack-composition","text":"Instead of creating one giant stack, I split the stack into multiple logical stacks. const app = new cdk . App (); // 1. Base infrastructure (deploy once) const base = new BaseInfraStack ( app , \"BaseInfraStack\" , { env : { account : \"123456789\" , region : \"us-east-1\" }, }); // 2. Backend services (dynamic features) const backend = new BackendStack ( app , \"BackendStack\" , { env : { account : \"123456789\" , region : \"us-east-1\" }, }); // 3. Website stacks (reusable pattern) new ResumeStack ( app , \"ResumeStack\" , { hostedZoneId : base.hostedZone.hostedZoneId , certificateArn : base.certificate.certificateArn , apiUrl : backend.apiUrl , cfSecret : backend.cfSecret , }); app . synth (); Why this pattern? Deploy common resources once : Route53 and ACM Certificates will be the same for subdomains, so it best fits for BaseInfraStack, whereas BackendStack will have API Gateway and Lambda functions and WebsiteStack will have S3 bucket and CloudFront distribution. Pass outputs between stacks : We can pass outputs of one stack to another stack. For example, we require the API GW url and secret from BackendStack to WebsiteStack. Reuse patterns : Now this pattern can be reused for any subdomain I will create.","title":"The Pattern: Stack Composition"},{"location":"posts/s3-static-website/#key-constructs","text":"Let me show you the most important constructs I built.","title":"Key Constructs"},{"location":"posts/s3-static-website/#1-s3-bucket-secure-by-default","text":"export class WebsiteBucket extends Construct { public readonly bucket : s3.Bucket ; constructor ( scope : Construct , id : string , props : MyBucketProps ) { super ( scope , id ); this . bucket = new s3 . Bucket ( this , \"Bucket\" , { bucketName : props.bucketName , websiteIndexDocument : \"index.html\" , blockPublicAccess : s3.BlockPublicAccess.BLOCK_ALL , // Security first! removalPolicy : RemovalPolicy.DESTROY , }); } }","title":"1. S3 Bucket (Secure by Default)"},{"location":"posts/s3-static-website/#2-cloudfront-distribution-multi-origin","text":"This was the challenging part - Static content from S3 (default behavior) - API requests to API Gateway (path /count ) export class WebsiteDistribution extends Construct { constructor ( scope : Construct , id : string , props : CloudFrontProps ) { super ( scope , id ); // Optional API origin for dynamic features const apiOrigin = props . apiUrl ? new origins . HttpOrigin ( extractDomain ( props . apiUrl ), { protocolPolicy : cloudfront.OriginProtocolPolicy.HTTPS_ONLY , customHeaders : { \"x-cf-secret\" : props . cfSecret . secretValueFromJson ( 'x-cf-secret' ). unsafeUnwrap () }, }) : undefined ; this . distribution = new cloudfront . Distribution ( this , \"Distribution\" , { defaultBehavior : { origin : props.s3Origin , viewerProtocolPolicy : cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS , }, // Route /count to API Gateway additionalBehaviors : apiOrigin ? { [ props . apiPath ] : { origin : apiOrigin , cachePolicy : cloudfront.CachePolicy.CACHING_DISABLED , }, } : undefined , domainNames : [ props . siteDomain ], certificate : props.certificate , }); } } How do I stop direct API access? I added x-cf-secret header to API requests injected by CloudFront, which the Lambda authorizer validates. This prevents direct API access!","title":"2. CloudFront Distribution (Multi-Origin)"},{"location":"posts/s3-static-website/#3-lambda-dynamodb-visitor-counter","text":"The counter Lambda tracks unique visitors by IP: def handler ( event , context ): src_ip = event . get ( \"headers\" , {}) . get ( \"x-forwarded-for\" , \"\" ) . split ( \",\" )[ 0 ] . strip () if not src_ip : return { \"statusCode\" : 400 , \"body\" : json . dumps ({ \"message\" : \"No IP found\" })} # Try to insert IP, fail silently if it exists try : table . put_item ( Item = { \"id\" : src_ip }, ConditionExpression = \"attribute_not_exists(id)\" # Only insert if new ) except ClientError as e : if e . response [ \"Error\" ][ \"Code\" ] != \"ConditionalCheckFailedException\" : raise # Count all unique IPs total = table . scan ( Select = \"COUNT\" )[ \"Count\" ] return { \"statusCode\" : 200 , \"body\" : json . dumps ({ \"ip\" : src_ip , \"unique_visitors\" : total }) } I know, I know, storing IP addresses is not the best way to do it, but it works for now (maybe Flask + SQLite in WAL mode. In-memory IP address rate limiting), but this is for the future. DynamoDB table: new dynamodb . Table ( this , \"CounterTable\" , { partitionKey : { name : \"id\" , type : dynamodb . AttributeType . STRING }, billingMode : dynamodb.BillingMode.PAY_PER_REQUEST , // Serverless pricing! });","title":"3. Lambda + DynamoDB (Visitor Counter)"},{"location":"posts/s3-static-website/#challenges-i-faced","text":"","title":"Challenges I Faced"},{"location":"posts/s3-static-website/#1-cross-stack-references","text":"Passing values between stacks required enabling crossRegionReferences : new BaseInfraStack ( app , \"BaseInfraStack\" , { crossRegionReferences : true , // Required! });","title":"1. Cross-Stack References"},{"location":"posts/s3-static-website/#2-api-gateway-authorizer","text":"Setting up the Lambda authorizer was tricky. The authorizer must return an IAM policy: def generate_policy ( principal_id , effect , resource ): return { \"principalId\" : principal_id , \"policyDocument\" : { \"Version\" : \"2012-10-17\" , \"Statement\" : [{ \"Action\" : \"execute-api:Invoke\" , \"Effect\" : effect , # \"Allow\" or \"Deny\" \"Resource\" : resource }] }, }","title":"2. API Gateway Authorizer"},{"location":"posts/s3-static-website/#3-github-oidc","text":"Setting up GitHub OIDC was a bit tricky. I had to enable the oidc provider in the github-actions.yml file: permissions : id-token : write contents : read","title":"3. GitHub OIDC"},{"location":"posts/s3-static-website/#testing-strategy","text":"","title":"Testing Strategy"},{"location":"posts/s3-static-website/#python-unit-tests-lambda-functions","text":"class CounterLambdaTest ( unittest . TestCase ): @mock . patch ( \"lambda_functions.counter.index.table\" ) def test_lambda_success ( self , mock_table ): mock_table . put_item . return_value = {} mock_table . scan . return_value = { \"Count\" : 123 } event = { \"headers\" : { \"x-forwarded-for\" : \"1.2.3.4\" }} response = handler ( event , None ) self . assertEqual ( response [ \"statusCode\" ], 200 ) self . assertIn ( \"unique_visitors\" , json . loads ( response [ \"body\" ])) Run tests: # Python tests python -m unittest discover -s ./test -p \"test_*.py\" -v","title":"Python Unit Tests (Lambda Functions)"},{"location":"posts/s3-static-website/#cicd-pipeline","text":"I use GitHub Actions with a six-stage pipeline: Setup \u2192 Install dependencies (cached) Tests \u2192 Run Python + CDK tests Plan \u2192 CDK diff (show changes) Approval \u2192 Manual approval for production Deploy \u2192 Deploy to AWS Notify \u2192 Send notifications Key features: - OIDC Authentication - No AWS credentials stored in GitHub! - PR Comments - Automatically comments CDK diff on pull requests - Manual Approval - Production deployments require approval","title":"CI/CD Pipeline"},{"location":"posts/s3-static-website/#lessons-learned","text":"After building this infrastructure, here are my key takeaways: Start Simple - Just start and start small and fast. Don't overcomplicate things. Use Constructs where possible - Reusable constructs have saved me hours from writing the same code again and again. Security Shift Left - I blocked public access to S3, used OIDC and implemented authorizers Stack Composition - Separating stacks makes it easier to maintain and also it is safer to update one stack without breaking the other.","title":"Lessons Learned"},{"location":"posts/s3-static-website/#whats-next","text":"Now that we have the foundation solid, here are some ideas I will be exploring:","title":"What's Next?"},{"location":"posts/s3-static-website/#1-monitoring-alerts","text":"We can use New Relic or Data Dog to monitor our simple infrastructure.","title":"1. Monitoring &amp; Alerts"},{"location":"posts/s3-static-website/#2-optimizing-costs","text":"It costs me less than $5 per month to run this infrastructure.","title":"2. Optimizing Costs"},{"location":"posts/s3-static-website/#3-waf-for-security","text":"Protect against DDoS and common attacks with AWS WAF rate limiting. (but this is expensive!)","title":"3. WAF for Security"},{"location":"posts/s3-static-website/#conclusion","text":"It was fun doing this, and I learned a lot about CDK and AWS. As a developer, I find CDK fluid and feels like I am slipping into a familiar pair of shoes. We get to use constructs, functions, loops and variables and suddenly infrastructure stops feeling like configuration files and starts feeling like code.","title":"Conclusion"}]}